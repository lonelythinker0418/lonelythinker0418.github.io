---
title: "LeetCode 972. Equal Rational Numbers Analysis" 
date: "2019-04-29" 
categories: cpp programming algorithm problemsolving onlinejudge LeetCode Hard 
--- 

Hello to whoever is reading this post! I realised that a good friend of mine is working on LeetCode problems, and I decided to attempt some LeetCode problems too when I have time. Afterall, I like solving puzzles, thinking about algorithms and just taxing my brain to solve hard problems. This doesn't mean though, that I'll be solving LeetCode problems. I'll just post whatever fun Math, Computer Science or Brainteaser that I come across in my life. 

The problem I am going to discuss briefly today is <a href = "https://leetcode.com/problems/equal-rational-numbers/"> Equal Rational Numbers. </a> 



``` 
class Solution {
public:
    /*
    Extract the integer, non-repeating decimal part and repeating decimal part
    */
    void extract(string s,string &intpart,string &nonrepeating,string &repeating){
          int idx1 = s.find('.');
          int idx2 = s.find('(');
          int idx3 = s.find(')');
          if (idx1 != string::npos){
            intpart = s.substr(0,idx1);
            nonrepeating = s.substr(idx1+1,idx2-idx1-1);
            if (idx3 != string::npos){
              repeating = s.substr(idx2+1,idx3-idx2-1);
            }
          }else{
            intpart = s;
          }
    }
    /*
    Checks if the string is only consisted of the character 0
    */
    bool only0s(string s){
        if (s.empty()) return false;
         for (int i = 0; i < s.size(); i++){
            if (s[i] != '0') return false;
         }
        return true;
    }
    /*
    Checks if the string is only consisted of the character 9
    */
    bool only9s(string s){
      if (s.empty()) return false;
      for (int i = 0; i < s.size(); i++){
        if (s[i] != '9') return false;
      }
      return true;
    }
    /*
    Increment a number represented by string by 1
    */
    string increment(string s){
      string res = s;
      int idx = res.size()-1;
      while (idx >= 0 && res[idx] == '9'){
        res[idx] = '0';
        idx--;
      }
      if (idx == -1){
        return "1"+res;
      }
      int added = (res[idx]-'0')+1;
      res[idx] = char(added + '0');
      return res;
    }
    /*
    Checks if two rational numbers are equal
    */
    bool isRationalEqual(string S,string T){
      string s_integer,s_non_repeating,s_repeating;
      string t_integer,t_non_repeating,t_repeating;
      extract(S,s_integer,s_non_repeating,s_repeating);
      extract(T,t_integer,t_non_repeating,t_repeating);
      if (only9s(s_repeating)){
        if (!s_non_repeating.empty()){
          if (only9s(s_non_repeating)){
            s_non_repeating = "";
            s_integer = increment(s_integer);
          }else{
            s_non_repeating = increment(s_non_repeating);
          }
        }else if (!s_integer.empty()){
          s_integer = increment(s_integer);
        }
        s_repeating = "";
      }
      if (only9s(t_repeating)){
        if (!t_non_repeating.empty()){
          if (only9s(t_non_repeating)){
            t_non_repeating = "";
            t_integer = increment(t_integer);
          }else{
            t_non_repeating = increment(t_non_repeating);
          }
        }else if (!t_integer.empty()){
          t_integer = increment(t_integer);
        }
        t_repeating = "";
      }
      if (only0s(s_repeating)) s_repeating = "";
      if (only0s(t_repeating)) t_repeating = "";
      if (s_integer != t_integer) return false;
      if (s_repeating.empty() && t_repeating.empty()){
        if (only0s(s_non_repeating)) s_non_repeating = "";
        if (only0s(t_non_repeating)) t_non_repeating = "";
        return s_non_repeating == t_non_repeating;
      }
      string s_merge = s_non_repeating+s_repeating;
      string t_merge = t_non_repeating+t_repeating;
      if (!s_merge.empty() && t_merge.empty()) return false;
      if (s_merge.empty() && !t_merge.empty()) return false;
      for (int i = 0; i < min(s_merge.size(),t_merge.size()); i++){
        if (s_merge[i] != t_merge[i]) return false;
      }
      return true;
    }
};
```
